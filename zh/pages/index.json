[{"section":"Notes","slug":"/zh/notes/tutorial-how-to-use-server/","title":"远程服务器怎么用才顺手","description":"","date":"2025年7月13日","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","searchKeyword":"","categories":"Tips","tags":"Ubuntu","content":"背景 相信大家平时习惯用的都是Windows系统和MacOS系统居多，用Ubuntu这类的Linux系统的机会可能相对少一些。但是，绝大多数的服务器装的其实都是Linux系统。\n就我亲身经历而言，对于Vivado这个软件，用Linux系统相较于用Windows系统做编译，在同样硬件条件下，测出来过高达5倍的速度提升。一个Windows下30个小时才能编译出来的超大规模程序，在Linux下可以做到6小时以内。另外，同等硬件下，Matlab的计算效率在Linux下也更高，尤其是并行计算时。\n正因如此，后续课题组内安装服务器的时候，我都会建议优先安装Linux系统，虽然上手稍微难一点，但后续的效率提升所带来的收益，远大于前期的探索成本。\n本文不涉及可视化界面，因为很多场景下用可视化界面连接服务并不稳定，体验也并不好，仅通过ssh在很多计算场景下就能获得非常好的体验。另外，本文默认大家已经掌握通过命令行的ssh命令进入服务器的方法。以下内容聚焦于：\n如何方便地在自己电脑上对远程服务器上的文件进行访问、修改；\n如何查看远程服务器的系统资源消耗；\n如何通过创建会话，实现关闭终端而程序不中断。\n通过这三点，希望能帮助大家扫清最开始使用Linux服务器的一些上手障碍。\n👨‍💻用Vscode直接进行远程代码编写 为什么？ 相信很多同学都是先在本地对程序进行编写、调试，然后再通过sftp对文件进行上传，在远处直接执行。但是这会带来几个问题：\n本地写的代码会跟远程服务器上的代码有些许出入，比如执行次数、是否并行、是否采用GPU等，如果采用这个方法的话，每一次代码的改动都需要进行一次上传，效率降低； 整个流程需要多个软件配合使用，来回切换，效率降低； 如果中间过程还会产生log之类的文件，想要实时观测log内容，还需要反复同步，效率降低； 等等。 其实我们常用的vscode就完全可以做到“像本地文件一样”操作远程服务器上的代码，非常好用且高效。\n怎么做？ 先安装vscode，并在扩展市场中安装Remote - SSH插件 修改配置文件，依次点击左下角的蓝色按钮——连接到主机——配置SSH主机——选择用户名下的那个配置文件。 在配置文件下，添加如下内容：\nHost myserver HostName 192.168.x.x User myname IdentityFile ~/.ssh/id_rsa 这个本质上跟点击蓝色按钮——连接到主机之后输入ssh myname@192.168.x.x是一样的效果，不过保存成配置文件之后，以后连接就不需要反复输入这串命令了。另外，IdentityFile这一行不是必选，这个是进行密钥校验用的，具体可以去网上查一下“如何通过密钥连接服务器”，这一步可以跳过密码验证，如果没有这一行的话，每次连接的时候手动输入一下密码就行。\n配置完成，连接服务器：再次点击蓝色按钮——连接到主机，此时能看见刚刚配置的服务器名\u0026quot;myserver\u0026quot;，点击之后便进行连接。 连接之后选择打开文件夹，进入你想要的路径，接下来你的所有代码操作都可以在Vscode中完成了，跟本地使用的方法是一样的。 还有一些需要注意的地方：\n远程服务器上的插件是需要重新安装一次的，点击这个云的按钮即可选择需要安装的插件 第一次连接速度会比较慢，因为有一系列东西vscode会自动进行安装，这个过程取决于网速 个人用例 我习惯了用vscode写程序，旁边放一个终端（vscode也自带终端，可以直接用），用SSH连接到远程服务器。用vscode修改程序并保存之后，直接通过终端在远程服务器上执行脚本查看输出。\n比如我用matlab的时候，我会先通过matlab -nodesktop进入无界面的matlab环境，接下来在里面执行脚本程序即可。\n查看系统资源消耗 为什么？ 我们登录服务器的时候，最常见的问题就是：现在这台机器忙不忙？能不能跑？跑的是什么？\n常用的有 top、htop 、glances这些命令，其中 glances 还支持web远程查看，这样我就可以用浏览器直接接入了。\n怎么做？ 看你喜欢哪一款，top是自带的，基本使用足够了，其他两款用命令行安装即可，具体看需求安装。注意，安装过程可能需要管理员权限，可以让管理员完成。安装命令分别如下：\nsudo apt install htop sudo apt install glances 其中，glances还支持浏览器直接访问，具体的安装过程问一下大模型即可，非常容易，如下：\n基本界面如下。如果你喜欢可以安装，如果基本功能就够了，那就直接用系统自带的top即可\n用Byobu进行会话管理 为什么？ 场景非常常见：你开了一个远程终端，跑了一个模型训练，结果突然网络断了——程序直接终止，几个小时白跑。\n用 byobu 管理会话，就能避免这类跑到一半不敢退出的场景。 它允许你把当前终端“挂起来”，哪怕你断网了，任务照常运行，回来还能接着看输出。\n怎么做？ 安装：\nsudo apt install byobu 启动：\nbyobu 常用操作（进入byobu之后）：\n功能 快捷键 创建新会话 Ctrl + a → c 退出/删掉当前会话 输入 exit ，回车 上一个/下一个会话 Ctrl + a → p/n detach 会话，即离开byobu环境，但是byobu在后台继续执行，可以随时重新进来 Ctrl + a → d 重新连接 byobu attach 重命名当前会话为newname byobu rename-window newname 这里的意思是Ctrl + a之后，Ctrl键不要松，直接接下一个键\n其他用法\n启用状态栏显示会话名：\nbyobu-status --enable-session-name 如果想每一次连接SSH都能直接进入byobu环境的话，可以执行\nbyobu-enable 查看/选择后端（推荐使用tmux）\nbyobu-select-backend 个人用例 我跑一个仿真，经常需要跑一整晚，甚至两三天。每次我都会先进入byobu环境，“创建一个新会话”，给这个会话改一个好记的名字（不然会话多了就忘了这个会话执行什么内容了）然后在里面运行训练脚本，再 Ctrl + a d 挂起来。哪怕回宿舍关电脑，第二天一早 ssh 上去 byobu attach 一下，模型还在继续跑，日志全都在。妈妈再也不会担心仿真中断了。以下是界面示例：\n"},{"section":"Notes","slug":"/zh/notes/reflection-wechat-official-account/","title":"吐槽微信公众号的推送模式","description":"","date":"2025年7月4日","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","searchKeyword":"","categories":"Reflections","tags":"Reflections","content":"前段时间看见公众号“修明札记”的一篇文章“微信公众号已死！！！”。标题起的吸引眼球，里面主要的观点是“微信公众号死了！微信团队为了流量，东施效颦，将微信公众号变成了第二个今日头条，丧失自己的特色，微信公众号将不可避免的走向衰败！运营这样的公众号，已无意义。”\n我并不喜欢这种情绪输出这么直接的文章，但是我确实也意识到了微信近期在公众号推送模式上的改版有趋同“今日头条”之嫌，标题、流量大于内容本身，劣币驱逐良币，让人失望。因此，从自身角度，我是认同作者的观点的。\n很直观的一个感受是，我以前关注的公众号，尤其是一些更新频率不算太高或者我点进去频率不算太高的推送，越来越难出现在我的视野中了；取而代之的是那些从没关注过的，可能跟我兴趣点相关的，但我并不希望在微信里给我推，而是在我需要的时候再自行搜索的内容，越来越占据重要的版面。\n此外，微信多次更新之后，公众号列表也进行了大改版，从最初直接以列表形式能看见所有已关注公众号；到后来公众号以头像的形式在顶部横向滑动；到现在公众号列表入口，都往里藏了两三层。我关注的公众号百余个，但是似乎每天给我推送的就那么十几二十个。\n我电脑版微信的公众号页面，只有默认前面5条是我关注的公众号发的内容，从Top Stories开始，都是推荐算法给推送的。而推送的内容往往都只是标题符合我的兴趣，实质并没有什么深度。\n一直以来，我都有刷微信推送的习惯，与很多身边喜欢刷知乎等内容密度比较高的平台的朋友不同，我更偏向于通过微信公众号来获取高价值高密度的信息，顺便通过诸如“央视新闻”，“新华社”之类的新闻公众号来补齐我平时不看新闻软件所缺失的实时信息。于是乎，微信推送近乎是我唯一的信息来源。（细想了一下还真是，我不刷小红书、不刷知乎、不刷新闻软件，平时没事就刷微信，刷B站，而B站其实只是为了娱乐，微信就成为我近乎唯一的信息来源了。）\n我以前一直认为，微信在旧版的订阅制推送框架下，作者是会有主观意愿去生产高质量、有深度、有广度的内容的，并且公众号还有打赏功能，对作者的收入也能产生不少的提升，更加鼓励作者生产优质内容。\n在2016年左右，在读本科的我也在兴趣下开了一个公众号。回想起那个时候，我会花不少时间去想如何能写一点有意思的、有思考的内容，有人评论或点赞我也会非常开心，并且也有一些固定的产生共鸣的读者一起思考、一起讨论。尽管后来没做了，但是，我认为在“当时的那种场景”下，作为一个公众号作者，我会有意愿生产相对高质量的内容。\n我所认为的“当时的那种场景”这个概念虽然有点模糊，但我内心也有个大概的框架，那就是：\n已经积累的读者要能及时收到作者写的文章，及时阅读并产生讨论； 对那些标题党而本身没有高质量内容的文章，应该适当减轻他们的权重，不让他们从中吃香； 合适的让作者变现的机制； 整体创作氛围良好，让读者群体认可这个平台，而不是提到微信公众号就让人主动类比“百家号”，“UC震惊体”这类令人绕道的平台。 当然我不是微信的产品经理，我也好长时间没有写过公众号了，我所想的东西可能过于理想过于简单。但是我作为一个读者，我认为现在微信给我推送的内容在往哗众取宠、取悦读者、简化读者思考的方向走，而微信公众号一直以来的护城河，恰恰在于文章质量，如果文章质量大幅降低，流量大于内容，那么你相比“今日头条”、“百家号”来说，有什么区别呢？我从内心里希望微信团队能想出好的方案，让微信公众号的内容质量保持原有的水准，提高读者的阅读体验以及思想深度。\n除此之外，鉴于现在AI发展迅猛以及我对AI发展的想象，我认为当下的腾讯混元接入deepseek之后，能够直接检索公众号内容并做出回答，这本身也是一种护城河，现在网上绝大多数内容并不靠谱，而如果检索出来的内容来自微信公众号，并且点开一看是某知名作者的内容，那可信度自然较高，用户自然也更信任混元的输出，从长期发展来看，对腾讯整体的发展必定是有益的。\nP.S. 之所以写这些，是因为最近在Top Stories信息流中看见了一个让我不吐不快的标题党推送。反正我看完之后是气笑了，为那些踏踏实实写文章的人鸣不平，毕竟，别人想两个好标题就能轻松10万+，换你你怎么想呢？\n这个推送10万+，点开里面\n好一篇小学生作文，比喻的修辞手法用的很娴熟啊，哪个大模型写的？嗯？这个公众号叫“夏津融媒音乐”？不是应该讨论音乐吗？为什么会讲新闻啊？点开看看\n好家伙，全是新闻，好几条数万阅读量的，这个公众号虽然名字是音乐，想必平时就喜欢发新闻，并且粉丝数量不少吧？嗯？怎么只有9篇原创内容？这么容易就10w+吗？看看往期的内容是什么质量\n前一篇推送有133阅读量。。。\n微信，还是花点心思在公众号上吧。。。这么劣币驱逐良币，最终是会被反噬的。\n"},{"section":"Notes","slug":"/zh/notes/pdf-to-eps/","title":".pdf转.eps","description":"","date":"2025年6月23日","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","searchKeyword":"","categories":"Tips","tags":"Software","content":" 这里讨论的方法是针对Mac的，但是如果你将本文复制，粘到ChatGPT里，让它给你提供其他系统下的方案，肯定没问题。\n基本转换方法 采用pdftops 采用Ghostscript（pdftops和GS这两种方法都可以直接将pdf文件转成eps，但是我个人觉得不太满意，输出的eps是格栅化后的，放大之后能看见锯齿，但是本文主要就是提供这种方法的脚本） 用原来作图用的软件重新导出（效率最低，效果最佳，还是这种最好） 前两种方法应该是安装MacTex之后命令行自带了，可以自行打开命令行，输入pdftops或者gs看看输出\n有输出就证明这两个软件可用了。下面提供利用Ghostscript进行转换的批处理脚本。\nGhostscript批处理脚本 生成自ChatGPT\n#!/bin/bash # 设置输出目录（可选） output_dir=\u0026#34;./eps_output\u0026#34; mkdir -p \u0026#34;$output_dir\u0026#34; # 遍历当前目录下所有 pdf 文件 for pdf_file in *.pdf; do # 提取文件名（不含扩展名） base_name=\u0026#34;${pdf_file%.pdf}\u0026#34; eps_file=\u0026#34;$output_dir/${base_name}.eps\u0026#34; echo \u0026#34;Converting $pdf_file -\u0026gt; $eps_file\u0026#34; gs -dNOPAUSE -dBATCH -dSAFER \\ -sDEVICE=eps2write \\ -dEPSCrop \\ -sOutputFile=\u0026#34;$eps_file\u0026#34; \u0026#34;$pdf_file\u0026#34; done echo \u0026#34;All conversions done.\u0026#34; 在你需要转换的pdf文件夹下，新建一个pdf2eps.sh文件，粘这部分内容进去，保存关闭。 运行命令行，修改该脚本的权限sudo chmod +x ./pdf2eps.sh 执行该脚本，./pdf2eps.sh即可完成该文件夹内的所有pdf文件转换 声明：转换之后请自行检查文件是否转换成功，别到时提交上去的时候发现有问题。\n"},{"section":"Notes","slug":"/zh/notes/build-vpn/","title":"在国外留学，如何更快速访问国内网站","description":"","date":"2025年6月20日","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","searchKeyword":"","categories":"Tips","tags":"Software","content":" 声明：本文只用来做技术交流，如果你有更便捷易用的方法，欢迎讨论。\n背景 在国外高校（如 UTS、Macquarie University 等）学习时，常常会遇到访问中国国内网站速度缓慢的问题。例如，阿里系网站、国内高校官网等，加载速度令人抓狂，想查看一下学校通知都加载不出来，严重影响生产效率，亟需提速。\n原理解析：其实是学校把部分回国流量屏蔽了 学校的网络通常会通过防火墙对特定网站进行屏蔽或限制，尤其是针对某些地区的流量。为了绕过这些限制，我们需要在数据传输过程中对流量进行加密，使学校的防火墙无法识别具体内容。具体来说，我们的设备先将流量加密并发送到中转服务器（VPS），由服务器代为请求目标网站，再将响应数据加密返回给我们。这样一来，学校的防火墙只能看到加密的数据流，无法判断我们访问了哪些网站，从而实现绕过限制的目的。其实，有很多高校是提供VPN方便校外学生访问学校内部资源的，借助VPN也能提高国内网站的连接速度，不过可惜的是，我所在的学校只提供WebVPN了，标准的VPN需要找学校申请，有点麻烦，不如自己想办法解决。\n知道原理后，解决思路就比较清晰了，这里提供两种方案：\n用现成的网络安全加密类的工具，推荐Warp 自己搭建一个服务器，构建一个加密通路 Warp CloudFlare提供了一个全平台的软件Warp，下载下来直接可用。其核心功能是通过加密你设备与互联网之间的流量，提升上网的安全性和私密性，同时优化网络连接速度。WARP 基于 Cloudflare 全球分布的数据中心网络，能够有效减少延迟，让你访问网站时更加流畅。\n链接：Warp\n下载下来打开并开启即可。\n第二种方案门槛比较高，我自己也不会。\n"},{"section":"Notes","slug":"/zh/notes/my-color/","title":"我的配色方案","description":"","date":"2025年5月20日","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","searchKeyword":"","categories":"Tips","tags":"Resource","content":" 分享一些色彩资源和个人想法，流水账式。欢迎讨论\nPPT、框图配色 在进行PPT制作或者进行框图绘制的时候，经常会头疼于颜色如何选取、搭配。你一定见识过大红大紫，饱和度拉满的PPT，也许别人比较注重内容了吧，但我希望我做出来的PPT不会是那样子的。作为一个大学生，我觉得基本的审美还是要有的，且不说高大上，起码看起来观众不会立马跑掉吧。\n都说一页PPT或者一张框图最多三四种配色，道理我都懂，但是到底怎么搭配啊？我简单看过一些设计相关的网站，比如谷歌的Material Design，但是这种网站是为设计师准备的，主要是指导设计原则类的，似乎不是我这种懒人准备的。尽管页面里也有Color resources，但毕竟不是拿来就用。特别是对于我这样没有经过设计训练的人来说，看懂了也不是那么容易学得会的。\n其实还有很多色卡类网站\ncolor hunt colordrop Grabient Picular Adobe Color ColorSpace 等等 按理说足够用了，但是始终感觉还是不得劲。每个网页进去都是这样的\n也多少会有点选择困难。\n最近有人做了一个项目CNScolor，里面可能会有一些指导性的配色方案，可以参考。\n后来，我发现了一些更简单的整套的配色方案——主题色。比如我们平时用vscode时所选用的theme，里面就会涉及到一整套的配色方案。在实践中，我发现Nord theme很好用，我也试过用这个主题色做过一个学术汇报的PPT（VTC 2025 Presentation），感觉还不错，可以试试。\nHappy Hues也提供了不少的主题色，可以探索一下。\nMatlab绘图 目前看到了Colormap by pratiman 这是一个博客，里面提供了好多配色方案，用来绘制热力图之类的应该比较好用。\n"},{"section":"Notes","slug":"/zh/notes/bi-awgn-initialize/","title":"BI-AWGN信道接收概率初始化","description":"","date":"2023年10月7日","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","searchKeyword":"","categories":"Communication","tags":"Signal Processing","content":" 内容参考：《Iterative Error Correction Turbo, Low-Density》\n接收信号概率一般怎么衡量？ 用Log likelihood ratios (LLRs)对数似然比来衡量。LLR定义如下：\n$$ L(x)=\\log \\frac{p(x=0)}{p(x=1)} $$\n其中$p(x=1)=1-p(x=0)$，log是以自然对数$e$为底的。若$p(x=0)\u0026gt;p(x=1)$，有$L(x)$为正。\n若给定LLRs，可以利用下述公式反求概率值：\n$$ p(x=1)=\\frac{p(x=1) / p(x=0)}{1+p(x=1) / p(x=0)}=\\frac{e^{-L(x)}}{1+e^{-L(x)}} $$\n$$ p(x=0)=\\frac{p(x=0) / p(x=1)}{1+p(x=0) / p(x=1)}=\\frac{e^{L(x)}}{1+e^{L(x)}} $$\n用对数来表达概率值的一个好处是当概率之间需要用乘法的时候，换成对数就可以只用加法进行了，可以节省实现复杂度。\nBI-AWGN信道接收概率初始化 Binary-input additive white Gaussian noise (BI-AWGN)信道可以用方程描述如下：\n$$ y_{i}=\\mu x_{i}+z_{i} $$\n其中，$x_i\\in {-1, +1}$是第$i$个传输符号，$y_i$是第$i$个接收符号，$z_i$是服从均值为0，方差为$\\delta^2$高斯随机分布的加性噪声。很多时候会写成$z_i=AWGN(0, \\delta)$的形式。\n$z$的概率密度函数为\n$$ p(z)=\\frac{1}{\\sqrt{2 \\pi \\sigma^{2}}} e^{-z^{2} / 2 \\sigma^{2}} $$\n当在BI-AWGN信道传输二进制码字时，码字比特$c_i\\in {0, 1}$可以按以下两种方式映射为符号$x_i\\in {-1, +1}$： ${0 \\rightarrow 1,1 \\rightarrow-1}$ 或 ${0 \\rightarrow-1,1 \\rightarrow 1}$。此处以${0 \\rightarrow 1,1 \\rightarrow-1}$举例。\nBI-AWGN信道接收到的LLRs为\n$$ \\begin{aligned} R_{i}=L\\left(x_{i} \\mid y_{i}\\right) \u0026amp;=\\log \\frac{p\\left(c_{i}=0 \\mid y_{i}\\right)}{p\\left(c_{i}=1 \\mid y_{i}\\right)} \\\\ \u0026amp;=\\log \\frac{p\\left(x_{i}=1 \\mid y_{i}\\right)}{p\\left(x_{i}=-1 \\mid y_{i}\\right)} \\\\ \u0026amp;=\\log \\frac{p\\left(y_{i} \\mid x_{i}=1\\right) p\\left(x_{i}=1\\right) / p\\left(y_{i}\\right)}{p\\left(y_{i} \\mid x_{i}=-1\\right) p\\left(x_{i}=-1\\right) / p\\left(y_{i}\\right)} \\\\ \u0026amp;=\\log \\frac{p\\left(y_{i} \\mid x_{i}=1\\right) p\\left(x_{i}=1\\right)}{p\\left(y_{i} \\mid x_{i}=-1\\right) p\\left(x_{i}=-1\\right)} \\end{aligned} $$\n其中用到了贝叶斯公式：$p\\left(x_{i} \\mid y_{i}\\right)=p\\left(x_{i}, y_{i}\\right) / p\\left(y_{i}\\right)=p\\left(y_{i} \\mid x_{i}\\right) p\\left(x_{i}\\right) / p\\left(y_{i}\\right)$，如果符号等概出现，即$p(x_i=-1)=p(x_i=1)$，则有\n$$ R_{i}=L\\left(x_{i} \\mid y_{i}\\right)=\\log \\frac{p\\left(y_{i} \\mid x_{i}=1\\right)}{p\\left(y_{i} \\mid x_{i}=-1\\right)} $$\n对于BI_AWGN信道来说，有\n$$ \\begin{aligned} p\\left(y_{i} \\mid x_{i}=1\\right) \u0026amp;=\\frac{1}{\\sqrt{2 \\pi \\sigma^{2}}} \\exp \\left(-\\frac{\\left(y_{i}-\\mu\\right)^{2}}{2 \\sigma^{2}}\\right) \\\\ p\\left(y_{i} \\mid x_{i}=-1\\right) \u0026amp;=\\frac{1}{\\sqrt{2 \\pi \\sigma^{2}}} \\exp \\left(-\\frac{\\left(y_{i}+\\mu\\right)^{2}}{2 \\sigma^{2}}\\right) \\end{aligned} $$\n则对LLRs化简，有\n$$ \\begin{aligned} R_{i}=L\\left(x_{i} \\mid y_{i}\\right) \u0026amp;=\\log \\frac{\\frac{1}{\\sqrt{2 \\pi \\sigma^{2}}} \\exp \\left(-\\frac{\\left(y_{i}-\\mu\\right)^{2}}{2 \\sigma^{2}}\\right)}{\\frac{1}{\\sqrt{2 \\pi \\sigma^{2}}} \\exp \\left(-\\frac{\\left(y_{i}+\\mu\\right)^{2}}{2 \\sigma^{2}}\\right)} \\\\ \u0026amp;=\\log \\exp \\left(-\\frac{\\left(y_{i}-\\mu\\right)^{2}}{2 \\sigma^{2}}+\\frac{\\left(y_{i}+\\mu\\right)^{2}}{2 \\sigma^{2}}\\right) \\\\ \u0026amp;=\\frac{1}{2 \\sigma^{2}}\\left(-\\left(y_{i}^{2}-2 \\mu y_{i}+\\mu^{2}\\right)+\\left(y_{i}^{2}+2 \\mu y_{i}+\\mu^{2}\\right)\\right) \\\\ \u0026amp;=\\frac{2 \\mu}{\\sigma^{2}} y_{i} \\end{aligned} $$\n对于比特$c_i$的LLR值，有时被称作$c_i$的软判决。$c_i$的硬判决指的是，当$R_i$为正值时，返回 $c_i=0$ 或 $x_i=1$，若$R_i$为负值时，返回 $c_i=1$ 或 $x_i=-1$。\n其他变形 若考虑BI-AWGN信道噪声水平的相对值，将$\\mu=1$并通过调节$\\delta$来反映信道的噪声水平会方便一些，此时$R_i$可以写为：\n$$ R_{i}=\\frac{2}{\\sigma^{2}} y_{i} $$\n表示为$E_b/N_0$的形式\n噪声水平通常会通过每符号能量$E_s$与噪声谱密度$N_0$之比来表示：\n$$ \\frac{E_{s}}{N_{0}}=\\frac{\\mu^{2}}{2 \\sigma^{2}} $$\n之因此式$y_{i}=\\mu x_{i}+z_{i}$有时会写成如下形式：\n$$ y_{i}=\\sqrt{E_{s}} x_{i}+z_{i} $$\n对于BI-AWGN信道，以$r$作为信息比特与传输比特之比，即码率，对于二进制输入，$E_s$代表的就是每传输比特的能量。\n对于使用了纠错编码的信道来说，噪声水平经常用$E_b/N_0$来表示，其中$E_b$是每信息比特的能量。\n有\n$$ \\frac{E_{b}}{N_{0}}=\\frac{1}{r} \\frac{E_{s}}{N_{0}}=\\frac{1}{r} \\frac{\\mu^{2}}{2 \\sigma^{2}} $$\n则接收的LLR表示为：\n$$ R_{i}=L\\left(x_{i} \\mid y_{i}\\right)=4 \\frac{\\sqrt{E_{s}}}{N_{0}} y_{i}=4 \\frac{\\sqrt{r E_{b}}}{N_{0}} y_{i} $$\n当$\\mu$为1时，有\n$$ R_{i}=\\frac{4}{N_{0}} y_{i} $$\n其中，$E_b/N_0$还可以表示为dB的形式：\n$$ \\frac{E_{b}}{N_{0}}(\\mathrm{~dB})=10 \\log _ {10} \\frac{E_ {b}}{N_{0}}=10 \\log _{10} \\frac{\\mu^{2}}{2 r \\sigma^{2}} $$\n值得注意的是，$E_s$代表的是每传输符号（二进制输入则对应为比特）的能量，是传输符号而不是信息符号，而$E_b$代表的是每信息比特的能量，这两者隔了个码率。\n"},{"section":"Notes","slug":"/zh/notes/equalization/","title":"信道均衡算法","description":"","date":"2023年10月6日","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","searchKeyword":"","categories":"Communication","tags":"Signal Processing","content":" 参考文献： 《高阶QAM信号盲均衡算法研究》 《Algorithms for Communications Systems and their Applications》 《Hybrid Methods for Blind Adaptive Equalization: New Results and Comparisons》\n自适应均衡原理 自适应均衡器可以视为两部分组成：滤波子系统和自适应算法。所以本质上，均衡器也是一个滤波器，更严格地说，自适应均衡是自适应滤波器做补偿信道ISI来讲的一种应用。\n自适应均衡问题建模 参考书籍：《Algorithms for Communications Systems and their Applications》 From the knowledge of the probability distribution of the channel input symbols $\\lbrace a_k\\rbrace$ and from the observation of the channel output sequence $\\lbrace x_k\\rbrace$, we want to ﬁnd an equalizer $C$ such that the overall system impulse response is inter-symbol interference (ISI) free.\n假设一个非最小相位系统的有理传递函数为\n$$ H(z)=H_{0} \\frac{P_{1}(z) P_{2}(z)}{P_{3}(z)} $$\n其中， $H_ 0$为增益， $P_ 3(z)$ 和 $P_ 1(z)$ 为在单位圆内有零点的一次多项式，而 $P_ 2(z)$ 为在单位圆外有零点的一次多项式。对 $P_ 1(z)$ 和 $P_ 2(z)$ 求逆并用劳伦变换表示，为\n$$ \\begin{aligned} \u0026amp;P_{1}^{-1}(z)=\\sum_{n=0}^{+\\infty} c_{1, n} z^{-n} \\ \u0026amp;P_{2}^{-1}(z)=\\sum_{n=-\\infty}^{0} c_{2, n} z^{-n} \\end{aligned} $$\n因此有\n$$ H^{-1}(z)=\\frac{1}{H_{0}} P_{3}(z)\\left(\\sum_{n=0}^{+\\infty} c_{1, n} z^{-n}\\right)\\left(\\sum_{n=-\\infty}^{0} c_{2, n} z^{-n}\\right) $$\n由于输入信号是对称的，即 $\\left\\lbrace-a_{k}\\right\\rbrace$ 和 $\\left\\lbrace-a_{k}\\right\\rbrace$ 有相同的统计特性，因此，我们无法区分目标均衡器为 $H^{-1}$ 还是 $-H^{-1}$。所以均衡器的解为 $C=\\pm H^{-1}$ ，这能令整个系统的响应为 $\\Psi=\\pm I$。\n定理 如果输入符号是非高斯的，若输出符号\n$$ y_{k}=\\sum_{n=-\\infty}^{+\\infty} c_{n} x_{k-n} $$\n的输入输出服从同分布，则系统$\\Psi=\\pm I$。\n利用上述定理可以确定均衡器 $C$ 是否令输出分布收敛于输入分布。令代价函数为\n$$ J=E\\left[\\Phi\\left(y_{k}\\right)\\right] $$\n其中 $\\Phi$ 是选定的实数偶函数，则最优解为\n$$ C_{o p t}(z)=\\arg \\min _{C(z)} J $$\n这样就能找到$\\pm H^{-1}$时的$c$值。\n假设均衡器系数长为$N$，则\n$$ \\boldsymbol{c}_ {k}=\\left[c_ {0, k}, c_{1, k}, \\ldots, c_{N-1, k}\\right]^{T} $$\n令输入为\n$$ \\boldsymbol{x}_ {k}=\\left[x_ {k}, x_{k-1}, \\ldots, x_{k-(N-1)}\\right]^{T} $$\n有输出\n$$ y_{k}=\\sum_{n=0}^{N-1} c_{n, k} x_{k-n}=c_{k}^{T} \\boldsymbol{x}_ {k} $$\n同理，可以将系数简化为\n$$ c_{o p t}=\\arg \\min_{c} J $$\n假设$\\Phi$的导数为$\\Theta$，$J$关于$c$的梯度为\n$$ \\nabla_{c} J=E\\left[\\boldsymbol{x}_{k}\\Theta (y_k)\\right] $$\n为了最小化$J$，使用随机梯度下降算法\n$$ c_{k+1}=c_{k}-\\mu \\Theta\\left(y_{k}\\right) \\boldsymbol{x}_{k} $$\n其中 $\\mu$ 是自适应增益。值得注意的是，收敛到 $H^{-1}$ 还是 $-H^{-1}$ 取决于初始系数$C$的选择。\n均衡器迭代时所选择的代价函数 $\\Phi$ 很重要。\nPAM系统中的Sato算法 Sato代价函数定义为：\n$$ J=E\\left[\\frac{1}{2} y_{k}^{2}-\\gamma_{S}\\left|y_{k}\\right|\\right] $$\n其中\n$$ \\gamma_{S}=\\frac{E\\left[a_{k}^{2}\\right]}{E\\left[\\left|a_{k}\\right|\\right]} $$\n$J$ 的梯度为\n$$ \\nabla_{\\boldsymbol{c}} J=E\\left[\\boldsymbol{x}_ {k}\\left(y_{k}-\\gamma_{S} \\operatorname{sgn}\\left(y_{k}\\right)\\right)\\right] $$\n引入信号\n$$ \\epsilon_{S, k}=y_{k}-\\gamma_{S} \\operatorname{sgn}\\left(y_{k}\\right) $$\n假设自训练时伪误差的期望替代最小均方(LMS)判决算法中的误差项。其中，LMS算法的误差信号为\n$$ e_{k}=y_{k}-\\hat{a}_ {k} $$\n其中，$ \\hat{a}_ {k}$为符号 $a_ k$的判决，这是对样本 $y_ k$ 通过阈值判决器判决出来的结果。下图展示了输出样本$y_ k$时伪误差$\\epsilon_{S, k}$的函数。\n因此，Sato算法系数更新过程为\n$$ \\boldsymbol{c}_ {k+1}=\\boldsymbol{c}_ {k}-\\mu \\epsilon_ {S, k} \\boldsymbol{x}_ {k} $$\n通过证明可知，如果输出符号$\\lbrace a_{k}\\rbrace$是sub-Gaussian的，那么Sato代价函数在一定的滞后后能将系统导向唯一的$C=\\pm H^{-1}$。\nSato算法的局限性 在得到Sato代价函数最小时的唯一点的前提是假设输入符号的概率分布是连续的，如果概率分布是离散的，Sato算法的收敛特性将会不理想； 在$C=\\pm H^{-1}$时，伪误差$\\epsilon_{S, k}$并不为零，除非系统是二进制传输系统； 伪误差的方差可以在期望解的邻域内为不可忽略的值。 值得一提的是，我们在最小化代价函数时，函数中有一项$E\\left[\\left|y_{k}\\right|^{p}\\right]$ ，其中$p\\geq 2$ ，这意味着在代价函数中我们强调采样点幅值的贡献。\nQAM系统中的自适应均衡 Constant-modulus algorithm（CMA，恒模算法） 最早由Godard提出，其代价函数为：\n$$ J=E\\left[\\left(\\left|\\tilde{y}_ {k}\\right|^{p}-R_{p}\\right)^{2}\\right]=E\\left[\\left(\\left|y_{k}\\right|^{p}-R_{p}\\right)^{2}\\right] $$\n其中，$p$是一个参数，通常有 $p=1$ 或 $p=2$ 。由于代价函数 $J$ 取决于均衡器输出的绝对值的 $p$ 次方，因此，CMA不需要载波相位估计。下图是采用了CMA均衡器接收机的框图。\n上式的梯度为\n$$ \\nabla_{c} J=2 p E\\left[\\left(\\left|\\tilde{y}_ {k}\\right|^{p}-R_{p}\\right)\\left|\\tilde{y}_ {k}\\right|^{p-2} \\tilde{y}_ {k} \\boldsymbol{x}_ {k}^{*}\\right] $$\n常数$R_p$会选择成在均衡效果很好时令梯度为0的值，因此，有\n$$ R_{p}=\\frac{E\\left[\\left|a_{k}\\right|^{2 p}\\right]}{E\\left[\\left|a_{k}\\right|^{p}\\right]} $$\n为啥这里需要用两个期望相除而不是相除后再求期望？ 因为相除后再求期望还有一项协方差需要求，而这两个随机变量都是$a_k$，协方差不为0，因此如果相除后再求期望的话就不是半径的$p$次方的期望了。\n以64QAM星座图为例，利用上式，可以算出 $R_ 1 = 6.9$ 和 $R_ 2 = 58$。计算这两个半径的代码如下：\np = 2; E1 = 0; E2 = 0; for i = 1:2:7 for j = 1:2:7 E1 = 1/16 * (sqrt(i^2+j^2) ^ p) + E1; E2 = 1/16 * (sqrt(i^2+j^2) ^ (2*p)) + E2; end end E2/E1 半径$R_ 1=6.9$的圆在64QAM星座图中的相对位置如下：\n我们可以借助下式以利用梯度更新均衡器系数\n$$ \\boldsymbol{c}_ {k+1}=\\boldsymbol{c}_ {k}-\\mu\\left(\\left|\\tilde{y}_ {k}\\right|^{p}-R_{p}\\right)\\left|\\tilde{y}_ {k}\\right|^{p-2} \\tilde{y}_ {k} \\boldsymbol{x}_ {k}^{* } $$\n对于 $p=1$ 的情况，上式化简成：\n$$ \\boldsymbol{c}_ {k+1}=\\boldsymbol{c}_ {k}-\\mu\\left(\\left|\\tilde{y}_ {k}\\right|-R_{1}\\right) \\frac{\\tilde{y}_ {k}}{\\left|\\tilde{y}_ {k}\\right|} \\boldsymbol{x}_ {k}^{*} $$\n这就是CMA算法，而Sato算法是CMA算法的一个特例。\nCMA算法的优缺点 优点\n鲁棒性好 复杂度低 使用广泛 可以在载波恢复之前 缺点\nTime-to-convergence(TTC)较慢 收敛时会有一个常数相位偏移 Multimodulus Algorithm(MMA)多模算法 参考文献：《Hybrid Methods for Blind Adaptive Equalization: New Results and Comparisons》\nMMA将均衡器的输出分为同相分量与正交分量，对于方形的QAM星座图来说，MMA误差为\n$$ \\begin{array}{r} E_{n, R}^{m m a}=y_{n, R}\\left(y_{n, R}^{2}-R_{M}\\right) \\ E_{n, I}^{m m a}=y_{n, I}\\left(y_{n, I}^{2}-R_{M}\\right) \\ E_{n}^{m m a}=E_{n, R}^{m m a}+j \\cdot E_{n, I}^{m m a} \\end{array} $$\n$R$ 和 $I$ 分别代表实数和虚数分量，$R_M$ 是一个常数，定义为：\n$$ R_{M}=\\frac{\\mathrm{E}\\left\\lbrace a_{n}^{4}\\right\\rbrace}{\\mathrm{E}\\left\\lbrace a_{n}^{2}\\right\\rbrace} $$\nMMA算法优缺点 MMA算法对比CMA有更低的MSE，并且不需要相位恢复。然而，收敛速率与CMA是差不多的，并且鲁棒性更低。\nDecision Directed(DD)算法 DD算法在更新均衡抽头的时候用符号估计替换掉符号统计值。DD误差定义如下：\n$$ E_ {n}^{d d}=y_ {n}-\\hat{s}_ {n} $$\n其中 $\\hat{s}_ {n}$ 是符号点的估计。\nDD算法优缺点 DD算法有更低的MSE和更低的抖动。然而，只有当MSE低于一个固定的阈值的时候才会收敛，针对QAM星座图，有论文推导过其阈值。\nModified-CMA(MCMA) 相比CMA的误差函数，MCMA算法增加了一个星座图匹配误差项(constellation matched error, CME)。这能够极大地降低TTC和MSE。MCMA误差定义为：\n$$ E_{n}^{m c m a}=y_{n}\\left(\\left|y_{n}\\right|^{2}-R_{C}\\right)+\\beta \\eta_{n} $$\n其中$\\beta$ 是CME权重因子，$\\eta_ n$是CME项，其定义为：\n$$ \\eta_{n}=\\left.\\frac{d}{d x} g(x)\\right|_ {x=y_ {n, R}}+\\left.j \\frac{d}{d x} g(x)\\right|_ {x=y_ {n, I}} $$\n其中$g(x)$是CME函数，该函数对QAM星座图来说在符号点上为0，$g(x)$定义为：\n$$ g(x)=1-\\sin ^{2 p}\\left(\\frac{x \\pi}{2 d}\\right) $$\n其中，$p$是正整数，$d$ 是星座点间的距离。\nMCMA算法优缺点 相比CMA算法有更低的MSE，更低的抖动以及更快的TTC。然而，该算法需要提前做相位恢复，并且复杂度更高，若CME项通过查找表实现的话，需要消耗大量面积。\nCMA-MMA CMA-MMA算法在代价函数中采用非对称的做法，在同相滤波器(in-phase filter)中使用CMA误差，在正交滤波器(quadrature filter)中使用MMA误差。CMA-MMA误差定义如下：\n$$ \\begin{array}{r} E_{n, R}^{c m a-m m a}=y_{n, R}\\left(\\left|y_{n}\\right|^{2}-R_{C}\\right) \\ E_{n, I}^{c m a-m m a}=y_{n, I}\\left(y_{n, I}^{2}-R_{M}\\right) \\ E_{n}^{c m a-m m a}=E_{n, R}^{c m a-m m a}+j \\cdot E_{n, I}^{c m a-m m a} \\end{array} $$\nCMA-MMA算法优缺点 优点：\n相比CMA算法有更低的MSE 鲁棒性好 尽管MMA误差项会导致星座图旋转，也不需要提前做相位恢复 缺点：\n收敛速率差不多 可能会导致较大的抖动 CMA-Assisted Decision Adjusted Modulus Algorithm(CADAMA) CADAMA是一种双模式算法，首先用CMA来减小MSE来让改进第二模式中的判决步骤。The decision adjusted modulus algorithm(DAMA)的代价函数对每个QAM中的环来说都是0，将DAMA用在第二模式中，DAMA误差项定义为：\n$$ E_{n}^{d a m a}=\\min _ {i}\\left[y_ {n}\\left(\\left|y_{n}\\right|^{2}-R_{i}\\right)\\right] $$\n其中，$1 \\leq i \\leq p$ 且 $\\left\\lbrace R_{i}\\right\\rbrace_{i=1}^{p}$ 是QAM星座图中信号点对应的半径，$p$是大于1的整数。\nCADAMA算法的优缺点 优点：\n有更低的MSE 比CMA有更低的抖动 缺点：\n对于高阶QAM星座图来说需要更多的判决区域，这增加了选区错误的可能性 在信道失真严重时，DAMA算法代价函数的错误率太大，DAMA算法不能收敛，因此在均衡的初始阶段，使用DAMA算法不可靠，不能冷启动DAMA算法 CMA算法与DAMA算法之间的转换准则 CADAMA需要首先采用CMA来实现均衡器的初始化调整，并且当幅度均衡完成之后，切换到DAMA模式。由于DAMA是使每个QAM星座图中的圈对应的代价函数归为0来实现的，因此对于很多标准QAM星座图来说，其抖动可以降低18到25dB。\nCMA与DAMA的切换准则：使用goodness-of-fit test来对观测间隔内的半径直方图与QAM星座图的半径分布模板进行比较来指导切换的。\nQAM星座图半径分布模板 令 $p_ i$ 代表信号点半径 $i$ 的模板概率，则有 $p_i = (\\text{number of signal points on radius} \\quad i)/M$，其中 $M$ 为调制阶数，且有$\\sum_{i=1}^{\\rho} p_{i}=1$。\n观测间隔 用 $N$ 来表示观测间隔，其与 $M$ 的关系为：$N=\\kappa M$，观测间隔 $\\kappa M$ 可以生成一个针对每个符号 $a_ m$ 的观测值 $K$。此处可以采用 $\\kappa = 20$。\n盲均衡性能评价准则 收敛速度 一个具有较高收敛能力的算法通常冷启动能力比较强，即算法是“易于收敛”的。\n均方判决误差 均方误差MSE的定义：\n$$ M S E=E\\left\\lbrace|d(n)-\\mathrm{y}(n)|^{2}\\right\\rbrace $$\n其中，$d(n)$是期望信号，$y(n)$是均衡器输出。\n剩余ISI 定义盲均衡算法的评价指数ISI，表达式为：\n$$ \\operatorname{ISI}(n)=\\frac{\\sum\\left|\\mathbf{h}_ {w}(n)\\right|^{2}-\\max \\left|\\mathbf{h}_ {w}(n)\\right|^{2}}{\\max \\left|\\mathbf{h}_{w}(n)\\right|^{2}} $$\n$\\operatorname{ISI}(n)$ 表示第 $n$ 次迭代后的剩余码间干扰， $\\sum\\left|\\mathbf{h}_ {w}(n)\\right|^{2}$ 表示对联合冲激响应 $\\mathbf{h}_ {w}(n)$ 的所有 $n$ 求平方之和， $\\max \\left|\\mathbf{h}_ {w}(n)\\right|^{2}$ 表示联合冲激相应 $\\mathbf{h}_{w}(n)$ 最大的一项的平方。\n误符号率 多数情况下，误符号率和盲均衡算法的均方判决误差以及剩余ISI是一致的。\n"},{"section":"Notes","slug":"/zh/notes/timing-recovery/","title":"定时同步算法","description":"","date":"2022年8月3日","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","searchKeyword":"","categories":"Communication","tags":"Signal Processing","content":"频域匹配滤波联合O\u0026amp;M算法定时同步 根据林长星的论文，可以在频域匹配滤波的时候使用延迟系数进行补偿，以达到定时同步的目标。其实现框图如下图所示。首先下变频后的数据会进行FFT运算，在频域对匹配滤波器系数进行FFT后的数值进行点乘，模拟时域的卷积运算，卷积完后的数据会与NCO算出来的定时误差进行频域的系数相乘操作，以实现时域数据的偏移，之后做IFFT得到最终匹配滤波与定时同步后的数据。定时同步后的数据会送入定时误差估计模块中，利用O\u0026amp;M算法进行定时误差的无偏估计，得到误差估计值$\\hat{\\varepsilon}$，该误差估计值$\\hat{\\varepsilon}$会被送入环路滤波器进行环路滤波，NCO则会对环路滤波的输出数据$\\varepsilon$进行溢出控制。\nO\u0026amp;M定时误差估计算法 O\u0026amp;M算法是由Oerder和Meyr由1988年提出的，这种算法需要至少4倍过采样，但是其误差估计值是真实值的无偏估计，在高信噪比下渐进等价于最大似然估计，而且算法对信噪比和载波频偏都不敏感，性能上会比Gardner算法更好，其主要推导过程如下。\n假设接收到的通过信道后的信号为\n$$ \\begin{equation} \\begin{aligned} r(t) \u0026amp;=\\sum_ {n=-\\infty}^{\\infty} a_ {n} g_ {T}(t-n T-\\varepsilon(t) T)+n(t) \\ \u0026amp;=u(t)+n(t) . \\end{aligned} \\end{equation} $$\n其中，$a_ n$ 为复信号（若为QPSK，则取值为 $\\pm 1, \\pm i$ ，即4个点在坐标轴上），$g_T(t)$为传输信号的单位脉冲响应，$T$是符号持续时间，$n(t)$为信道噪声，这里假设为功率密度是$N_0$的高斯白噪声，定时误差$\\varepsilon(t)$未知，且随时间变化缓慢。\n由于定时误差$\\varepsilon$变化很慢，在数字实现的时候，可以将信号分片，对于每一片信号$\\Delta_m$，我们可以假设$\\varepsilon$是一个常数，其估计值为$\\hat{\\varepsilon}$。该定时误差估计值需要与之前时刻的估计值进行结合（即需要进行滤波）以获得最佳估计值$\\bar{\\varepsilon}$，这个最佳估计值用于控制检测的采样器。\n假设接收端的冲激响应为$g_R(t)$，则接收到的信号为$\\tilde{r}(t)=r(t) * g_{R}(t)$，设采样率为$N/T$，则接收端采样值为$\\tilde{r}_ {k}=\\tilde{r}(k T / N)$，则接收端序列取平方后有\n$$ \\begin{equation} x_{k}=\\left|\\sum_{n=-\\infty}^{\\infty} a_{n} g\\left(\\frac{k T}{N}-n T-\\varepsilon T\\right)+\\tilde{n}\\left(\\frac{k T}{N}\\right)\\right|^{2} \\end{equation} $$\n其中$g(t)=g_ {T}(t) * g_{R}(t)$。上式代表对接收信号进行滤波以及平方之后的采样值，其频谱在$1/T$处有一个分量。\n对上述取平方后的序列以时长$LT$进行分片（即每个分片有$LN$个符号），对序列以符号速率求复傅里叶级数\n$$ X_{m}=\\sum_{k=m L N}^{(m+1) L N-1} x_{k} e^{-j 2 \\pi k / N} $$\n上述级数求归一化相位可得$\\hat{\\varepsilon}_ m=-1 / 2 \\pi \\arg \\left(X_{m}\\right)$，可以得出该归一化相位$\\hat{\\varepsilon}_m$是定时误差$\\varepsilon$的无偏估计。证明请直接参考原文章。\n这里值得注意的是，$\\arg()$算符并不等价于$\\arctan()$算符，因为$\\arctan()$的值域是$\\left(-\\frac{\\pi}{2}, \\frac{\\pi}{2}\\right)$，但$\\arg()$算符求的是当前的复向量的角相位，对应的值域是$\\left(-\\pi, \\pi\\right)$。\n思考：为何上式频谱会在$1/T$处有的分量？\n可以参考书籍《Digital Signal Processing Fundamentals and Applications》Fig. 4.3对于一个符号周期为$T$的信号，其频率为$f_0$，若以采样率$f_s=Nf_0=N/T$进行采样，则其频谱应该会在0-$fs$（即0-$Nf_0$）处有N个间隔为$f_0$的值，即上式一定会在$1/T$处有分量。这也证明了为何O\u0026amp;M算法需要大于2倍过采样，因为如果只有两倍过采样的话，在0-$f_s$频率范围内，只有N+1根谱线，分别为0, 1/T, 2/T这几根谱线，并且不满足奈奎斯特采样率，因此在1/T处会产生混叠，造成采集的数据不准确，影响后续的判断。\nO\u0026amp;M算法的特点 O\u0026amp;M算法的特点如下：\n至少需要4倍过采样 估算出来的定时误差$\\hat{\\varepsilon}$是真实定时误差的无偏估计 可以用于前馈也可以用于反馈结构 对频偏不敏感 对信噪比不敏感 前馈结构适用于突发通信 Gardner算法 阅读论文《A BPSK/QPSK Timing-Error Detector for Sampled Receivers》\nGardner算法基本公式\n$$ \\begin{aligned} u_{t}(r)=y_{I}(r-\\frac{1}{2})[\u0026amp;\\left.y_{I}(r)-y_{I}(r-1)\\right] \\\\ \u0026amp;+y_{Q}(r-\\frac{1}{2})\\left[y_{Q}(r)-y_{Q}(r-1)\\right] \\end{aligned} $$\n其中，$y_I(r)$中的$r$ 代表符号索引，It is convenient to denote the strobe values of the $r$th symbol- as $y_I(r)$ and $y_Q(r)$. 这里的strobe不太确定到底指的是采样值还是内插后的值。那么，在两个strobe之间的那个点的值就是$y_{I}(r-\\frac{1}{2})$和 $y_{Q}(r-\\frac{1}{2})$。这就是利用采样点计算出来定时误差$u_t(r)$的Gardner误差估计公式。\nGardner算法的特点 优点：\n只需要两倍过采样 缺点：\n需要40%-100%的额外带宽 为什么需要40%-100%的额外带宽呢？\n因为如果带宽过窄会引入自噪声。\n为什么会引入自噪声？自噪声哪里来的？\n看上图，如果$\\alpha=1$的话，即频谱扩展100%，可以看见1.5T处为0，这个时候采样$y_{I}(r-\\frac{1}{2})$和 $y_{Q}(r-\\frac{1}{2})$时不是处于过零点处，在计算定时误差时就会呈现散点的形式（而非零点），这种情况在求均值后是没问题的，关键就是如果只看局部，就会引入自噪声，而且随着$\\alpha$的减小，自噪声也越大。\nGardner定时误差公式解释 这条公式看上去很简单，也有很多不同的解释，但直接对这条公式进行的解释都是浮于表面的，也无法得知公式到底是怎么被想出来的，不如我们直接对Gardner的原文重新推导一遍，尝试得到原汁原味的思路。这里先给出Gardner原文对公式的解释。\nA physical explanation can be ascribed. The detector samples the data stream midway between strobe locations in each of the $I$ and $Q$ channels. If there is a transition between symbols, the average midway value should be zero, in the absence of timing error. A timing error gives a nonzero sample whose magnitude depends upon the amount of error, but either slope is equally likely at the midway point so there is no direction information in the sample alone.\nTo sort out these different possibilities, the algorithm examines the two strobe values to either side of the midway sample. If there is no transition, the strobe values are the same, their difference is zero, and so the midway sample is rejected. (No timing information is available in the absence of a transition.)\nIf a transition is present, the strobe values will be different; the difference between them will provide slope information. The product of the slope information and the midway sample provides timing-error information.\n按照我的理解尝试一下翻译过来，避免遗忘。检测器会对数据流的 $I$ 路和 $Q$ 的符号采样值(strobe)间的中间点(midway)进行采样（即式中的$y(r-1/2)$）（这个strobe的意思大意就是符号的最佳采样点处，但其实对于这篇论文，当时Gardner还没有提出定时同步环路，仅针对定时误差检测而言，此处的strobe不能直接理解为最佳采样点，而是一个正常的采样点，即该符号对应的其中一个采样点，为一个strobe，隔壁符号的对应的采样点，则为另一个strobe。举个例子，如果当前过采样倍数为4，若假设当前符号的第二个采样点为strobe，即 $y(r-1)$ ，则隔壁的strobe则在当前采样点往后顺延4个，即为下一个strobe， $y(r)$ 。midway的意思其实就是对于接收到的电平信号两个strobe之间的中点，还是以过采样倍数为4为例，如果当前采样序列的索引为1/2/3/4/5/6/7/8，若2为第一个strobe， $y(r-1)$ ，则4为midway， $y(r-1/2)$ ，6为第二个strobe， $y(r)$。而对于加了反馈环路的Gardner环来说，这里的strobe其实就是内插出来的最佳采样点了，不然每次都是用采回来的点进行求解，定时误差永远都不会收敛）。如果两个符号间有跳变，则在没有定时误差的情况下，midway点的平均值应该为0。定时误差会导致midway点采样值不为0，而该值的幅度会取决于误差的大小，不过如果公式中只有中间点这一项的话，还没办法得到位置信息，即超前还是滞后。\n为了得到位置信息，算法对midway两端的符号采样值进行衡量，即式中的$y(r)-y(r-1)$，如果两个符号间没有跳变，则两个符号采样值应该是相同的，即差值为0，那么中间相就被消掉了，此时没有定时信息（即如果没有跳变的话，是无法获取定时误差信息的）。\n如果有跳变，则符号采样值会不一样，该差值会提供斜率信息。斜率信息与midway值相乘会提供定时误差信息。\nGardner定时误差公式的推导 先看图，\n线A给出了符号的边界，符号的持续时间为$T$。 线B给出了最佳采样点的位置，即每个符号间隔的中间点处。 线C给出了一个基带信号，该基带信号经过了成型以及匹配，并且满足奈奎斯特准则，是个带限信号，且成型系数用的100%。 如何通过数据流重建一个时钟波形呢？一个已经被证明过的方法是将信号通过一个简单的整流器，如果采用平方律整流器的话，其实就是将数据进行平方。如线D所示，平方完后的信号有如下好处：\n噪声性能将近最优，尤其是在低信噪比时； 如果一个纯sin信号输入，则输出为一个二倍频的sin信号； 平方运算是该方法中唯一的非线性操作，该非线性操作在数学上是易于处理的； 该平方律整流器在I路和Q路将能独立恢复出载波相位的时钟波形，这在捕获阶段是比较重要的。 利用线D，可以将原型时钟(protoclock)生成出来，具体做法是，利用一个以符号速率为周期的纯sin波形，在数据非跳转处进行隔开，只在数据跳转处进行保留。这个原型时钟再通过一个窄带滤波器或者一个锁相环即可将想要的时钟线恢复出来，并且能消掉各种其他干扰，这就是模拟时钟恢复的方法。\n仔细分析可以发现，这个方法其实也可以用于数字系统中，但是并不方便，一个是运算量较大，另一个是仅两个采样点还不太够用，因为sin的周期等于符号周期，而sin一个周期仅两个采样点是不满足采样定律的，所以在数字系统，这个做法需要改进才能用。不过我们不是要重建原型时钟，而是要找到一个方法来计算定时误差，本质上是不需要重建原型时钟的。\n线E和线F对应一种预滤波方法(prefilter method)，由于Gardner没用这个方法，此处不再赘述。这是为了改进线D用到的方法而被提出的，有文献可以参考。\n延迟差分方法（Gardner用的方法）。\n令差分器能进行如下运算：\n$$ x_{d}(t)=x(t)-x\\left(t-t_{d}\\right) $$\n其中 $t_d$ 是一个预先算好的延迟时间。值得一提的是，假设 $t_d=T/2$ 则$x_d$的平均延时为$T/4$，即采样时刻与计算出来的定时误差时刻的时间偏移值（这里我理解还不够透彻，为什么平均延时为$T/4$，不过无伤大雅）（我的理解是，线D和线E算出来在时间上是与原信号对齐的，而用这个公式算出来会差$T/4$）。\n令 $t_d=T/2$ ，则线C进行延迟差分后可以得到线G。线G跟线E类似，不过线G并不是一个特定的信号波形（线E是一个sin信号）。这个线G有着跟线E几乎一样的周期特性。（这里为什么用 $t_d=T/2$ 而不是其他值暂时还没有想法，目前的想法是，间隔半个周期一个对标的是线D的形式，一个在上升沿则另一个会在下降沿，这么间隔 $t_d=T/2$ 求差之后就能比较好地反应出信号的跳变信息，但实际上仿真的时候可以看出，在 $t_d=T/4$ 到 $t_d=3T/4$ 之间似乎没有很大的区别）。\n从线G来看，能发现只有在初始信号有跳变的时候波形才会摆动，不然波形会归0。对线G进行平方，可以得到线H，可以看出，这样也生成了一个原型时钟，而定时误差信息可以通过计算 $E(r)$ 和 $L(r)$ 的差值获得。\n$$ u_{t}(r)=E(r)-L(r-1) $$\n其中，$E(r)$ 是第 $r$ 个符号的采样点，而 $L(r-1)$ 是第 $r-1$ 个符号的采样点，$E$ 对应的是提前的采样点， $L$ 对应的是滞后的采样点。\n接下来就是化简这个函数了。首先有\n$$ x_{d}(t)=x(t)-x(t-T / 2) $$\n平方后为\n$$ x_{d}^{2}(t)=x^{2}(t)+x^{2}(t-T / 2)-2 x(t) x(t-T / 2) $$\n在 $t=r T+\\tau$ 和 $r T+\\tau-T / 2$ 处采样，有\n$$ \\begin{aligned} E(r)=\u0026amp; x_{d}^{2}(r T+\\tau) \\\\ =\u0026amp; x^{2}(\\tau+r T)+x^{2}(\\tau+(r-1 / 2) T) \\\\ \u0026amp;-2 x(\\tau+r T) x(\\tau+(r-1 / 2) T) \\end{aligned} $$\n和\n$$ \\begin{aligned} \u0026amp;L(r-1)=x^{2}(\\tau+(r-1 / 2) T)+x^{2}(\\tau+(r-1) T) \\\\ \u0026amp;-2 x(\\tau+(r-1 / 2) T) x(\\tau+(r-1) T) \\end{aligned} $$\n令\n$$ u_{t}(r)=L(r-1)-E(r) $$\n将上式化简后可得\n$$ \\begin{aligned} \u0026amp;u_{t}(r)=x^{2}(\\tau+(r-1) T)-x^{2}(\\tau+r T) \\\\ \u0026amp;+2 x(\\tau+(r-1 / 2) T){x(\\tau+r T)-x(\\tau+(r-1) T)} \\end{aligned} $$\n上式能不能作为定时误差项呢？其实可以了，因为包含了定时误差信息在里面了，不过还可以继续化简。对上式求均值，有\n$$ \\begin{aligned} \u0026amp;U_{t}(\\tau)=\\operatorname{Avg}\\lbrace x^{2}(\\tau+(r-1) T)\\rbrace-\\operatorname{Avg}\\lbrace x^{2}(\\tau+r T)\\rbrace \\\\ \u0026amp;+2 \\operatorname{Avg}{x(\\tau+(r-1 / 2) T)(x(\\tau+r T)-x(\\tau+(r-1) T))} \\end{aligned} $$\n上式中第一项和第二项是相同的，因为是同一个信号不同延时而已，是周期平稳的随机信号，这两项可以直接消掉。对于输出信号来说，这两项$x^2(\\cdot)$ 来说，其存在并不会影响到有用信号的输出均值。剩下后面一项，这一项可以写为\n$$ \\begin{aligned} u_{t}(r) \u0026amp;=x(\\tau+(r-1 / 2) T){x(\\tau+r T)-x(\\tau+(r-1) T)} \\\\ \u0026amp;=x(r-1 / 2){x(r)-x(r-1)} \\end{aligned} $$\n这就是化简之后的Gardner误差检测公式。\n我们接下来写程序仿真看看\nclc; clear; close all; rand(\u0026#39;seed\u0026#39;, 1); data = 2 * randi([0 1], 1, 20) - 1; % data = 2 * [1 0 1 0 1 1 0 0 0 1 0 1 1 1 1 0] - 1; span = 16; sps = 100; rrc = rcosdesign(1, span, sps); data_shape = conv(upsample(data, sps), rrc, \u0026#39;same\u0026#39;); data_match = conv(data_shape, rrc, \u0026#39;same\u0026#39;); data_Diff = data_match(floor(sps/2)+1:end) - data_match(1:end-floor(sps/2)); data_Diff2 = data_Diff .^ 2; figure; subplot(5, 1, 1); plot(data_match); title(\u0026#39;data match\u0026#39;); grid on; subplot(5, 1, 2); plot(data_match(floor(sps/2)+1:end)); title(\u0026#39;data match 1\u0026#39;); grid on; subplot(5, 1, 3); plot(data_match(1:end-floor(sps/2))); title(\u0026#39;data match 2\u0026#39;); grid on; subplot(5, 1, 4); plot(data_Diff); title(\u0026#39;data diff\u0026#39;); grid on; subplot(5, 1, 5); plot(data_Diff2); title(\u0026#39;data diff2\u0026#39;); grid on; 上图中最后两个图分别对应线G和线H，采用的成型系数为1，如果用 $L$ 和 $E$ 直接采然后作差，其实就相当于与对原始信号按照 $x(r-1 / 2){x(r)-x(r-1)}$ 求解。\n程序都写了，不如我们改一下成型滤波器的$\\alpha$，看看自噪声这个东西到底长啥样吧。 直接将成型系数改为0.1，则有下图\n可以看出，成型系数变小之后，确实差了很多，引入了大量自噪声。\nGardner算法为何不受频偏影响？ 首先假设一个时间连续且通过了滤波器后的复信号：\n$$ w(t)={a(t)+j b(t)} e^{j \\Delta \\theta} $$\n该复信号拆分成实部与虚部分别为：\n$$ x_{R}(t)=a(t) \\cos \\Delta \\theta-b(t) \\sin \\Delta \\theta $$\n$$ x_{I}(t)=a(t) \\sin \\Delta \\theta+b(t) \\cos \\Delta \\theta $$\n其中$\\Delta \\theta$ 是载波相位误差，此处是随机的。对于定时误差估计，其算法为：\n$$ \\begin{aligned} u_{t}(t)\u0026amp;=x_{1}(t-T / 2)\\left[x_{1}(t)-x_{1}(t-T)\\right] \\\\ \u0026amp;+x_{2}(t-T / 2)\\left[x_{2}(t)-x_{2}(t-T)\\right] \\end{aligned} $$\n将其展开，有\n$$ \\begin{aligned} u_t(t)=\u0026amp;\\left(a(t-\\frac{T}{2})\\cos(\\Delta\\theta)-b(t-\\frac{T}{2})\\sin(\\Delta\\theta)\\right)\\cdot \\\\ \u0026amp;\\left[a(t)\\cos(\\Delta\\theta)-b(t)\\sin(\\Delta\\theta)-a(t-T)\\cos(\\Delta\\theta)+b(t-T)\\sin(\\Delta\\theta)\\right] + \\\\ \u0026amp;\\left(a(t-\\frac{T}{2})\\sin(\\Delta\\theta)+b(t-\\frac{T}{2})\\cos(\\Delta\\theta)\\right)\\cdot \\\\ \u0026amp;\\left[a(t)\\sin(\\Delta\\theta)+b(t)\\cos(\\Delta\\theta)-a(t-T)\\sin(\\Delta\\theta)-b(t-T)\\cos(\\Delta\\theta)\\right]\\\\ \u0026amp;=a(t-\\frac{T}{2})\\left[a(t)-a(t-T)\\right] + b(t-\\frac{T}{2})\\left[b(t)-b(t-T)\\right] \\end{aligned} $$\n从化简后的公式可以看出，载波频偏并不影响Gardner算法估计出来的定时误差。因此，Gardner算法可以用在载波恢复之前。\n"},{"section":"Notes","slug":"/zh/notes/polyphase-matched-filtering/","title":"基于多相滤波器技术的匹配滤波实现方法","description":"","date":"2022年5月28日","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n  \n\n\n  \n","searchKeyword":"","categories":"Communication","tags":"Signal Processing","content":" 以毕业论文《柔性速率可变的宽带16QAM16APSK调制解调器的设计与实现》为学习材料\n变速率成型滤波的实现 成型滤波的表达式 当基带系统的总特性等效为理想低通滤波器时，可实现无码间串扰，但理想的低通滤波器在实际中无法实现，因此在发射端利用根升余弦滤波器对发送信号进行成型滤波，在接收端也用根升余弦滤波器对接收信号进行匹配滤波，这样能使整个信道等效与与低通特性相近的滤波器，可以让系统在本码元的抽样时刻($t=0$)时的值最大，在其他码元抽样时刻($t=\\pm k T_{s}$)为0。\n根升余弦滤波器的时域响应为 $$ h_{T}(t)=h_{R}(t)=4 \\alpha \\frac{\\cos \\left((1+\\alpha) \\pi t / T_{s}\\right)+\\frac{\\sin \\left((1-\\alpha) \\pi t / T_{s}\\right)}{\\left(4 \\alpha t / T_{s}\\right)}}{\\pi \\sqrt{T_{s}}\\left(1-\\left(4 \\alpha t / T_{s}\\right)^{2}\\right)} $$\n基于数字重采样技术的速率转换方法的公式推导 什么是变速率，为什么要进行速率变换？为什么要进行高速并行可变符号速率调制？\n一般发射端DA或者接收端AD的采样率会在设计之初便定下来，以保证程序的正常运行，但是，符号速率有可能会根据实际情况进行调整，这样在相同的采样率下，符号的过采样倍数就会不同，而且有时过采样的倍数可能为小数，这样成型滤波器就需要专门设计，并且保证速率可变，以适应不同速率的输入信号。 由于FPGA内部处理时钟一般不超过200MHz，要实现高速信号Gbps调制，必须使用全并行架构，这时候调制就需要并行架构了。 根据奈奎斯特采样定理，只要采样频率大于信号带宽的两倍，就可以从采样值$x(nT_s)$中恢复出原始信号$y(t)$ $$ y(t)=\\sum_{n=-\\infty}^{+\\infty} x\\left(n T_{s}\\right) h\\left(t-n T_{s}\\right) $$ 这里$x(t)$为输入信号，$h(t)$为滤波器时域响应，$T_s$为符号周期。\n该公式的物理意义是：如果我当前要得到输出信号$y(t)$，那么我要对输入信号与滤波器进行卷积。而你会发现输入信号是离散的，其采样时刻为$nT_s$，而滤波器的时域响应是以$t$为原点的。这个公式非常的普通，但是必须要深入理解该公式才能理解后面的推导。\n如果对上面这个恢复的信号进行重采样，即我想获得某个我想要的点的信号，我会首先想到将上面公式中的$t$替换成我想要的点的时刻，比如$kT_{sp}$，有如下公式： $$ y\\left(k T_{sp}\\right)=\\sum_{n=-\\infty}^{+\\infty} x\\left(n T_{s}\\right) h\\left(k T_{sp}-n T_{s}\\right)=\\sum_{n=-\\infty}^{+\\infty} x\\left(n T_{s}\\right) h\\left(T_{s}\\left(\\frac{k T_{sp}}{T_{s}}-n\\right)\\right) $$\n这里的$T_{sp}$可以理解成DA的采样周期，其物理含义是我当前要对符号进行调制，给定了采样周期为$T_{sp}$，那么其通过上述公式可以求出其$y(kT_{sp})$，因为我当前的信息符号周期是$T_s$（偏慢），但是我DA采样的时候其采样周期为$kT_{sp}$（偏快），所以我需要利用上述公式对速率偏慢的信息符号通过成型滤波生成速率较高的信号，然后给到DA进行输出。\n可以看出，$x(nT_s)$是与$x(T_{sp})$无关的，只与$h(t)$有关。\n对上述公式进行化简，令$m_{k}=\\left\\lfloor\\frac{k T_{sp}}{T_{s}}\\right\\rfloor$，$\\mu_{k}=\\frac{k T_{sp}}{T_{s}}-m_{k}$，代入上式可得： $$ y\\left(k T_{sp}\\right)=\\sum_{n=-\\infty}^{+\\infty} x\\left(n T_{s}\\right) h\\left(\\left(m_{k}+\\mu_{k}-n\\right) T_{s}\\right) $$ 再令$m=m_{k}-n$，可得： $$ y\\left(k T_{sp}\\right)=\\sum_{m=-\\infty}^{+\\infty} x\\left(\\left(m_{k}-m\\right) T_{s}\\right) h\\left(\\left(\\mu_{k}+m\\right) T_{s}\\right) $$\n这里通过化简，$y(kT_{sp})$只与$x\\left(\\left(m_{k}-m\\right) T_{s}\\right)$以及$h\\left(\\left(\\mu_{k}+m\\right) T_{s}\\right)$有关，这里面涉及到的整数参数有$m_k, m$以及小数参数有$\\mu_k$，对于$x(t)$，由于里面的索引要求是整数的，所以$m_k-m$符合要求，此时抽取的是正常的$x$序列，而对于$h$，由于其涉及到小数，所以我们会先对$h$进行过采样，然后再正常抽取，但是这个$m$所对应的是原本没有偏移的正确采样点的位置，加上$\\mu_k$是偏移。\n疑问\n我个人觉得上面两条公式看上去是等价的，但是一旦把取值范围确定后，两条公式不是等价的吧？\n由于无法做到无穷项求和，所以可以将滤波器截短。 $$ \\begin{aligned} y\\left(k T_{sp}\\right) \u0026amp;=\\sum_{m=-I_{1}}^{I_{2}} x\\left(\\left(m_{k}-m\\right) T_{s}\\right) h\\left(\\left(\\mu_{k}+m\\right) T_{s}\\right) \\\\ \u0026amp;=\\sum_{m=-I_{1}}^{I_{2}} h_{T}\\left(\\mu_{k}+m\\right) x\\left(m_{k}-m\\right) \\end{aligned} $$ 由于$T_s$对于$x$和$h$来说都表示当前索引是在序列内抽取的，是一个倍数关系，所以这个倍数关系可以忽略掉，我们只要做好由$x((m_k-m)-T_s)$到$x(m_k-m)$的映射就可以了。\n可变速率成型滤波器设计 在FPGA中，由于无法实时计算$h_{T}\\left(\\mu_{k}+m\\right)$，因此采用查找表的形式来实现。过采样倍数决定了这里的$\\mu_k$的精度，如果设定$\\mu_k$的精度为$\\frac{1}{2^{-12}}$，那么对于5Gsps采样率来说，变速率的步进即为$1.22Msps$。\n按照上一节的说法，假设当前符号前后间隔超过3个符号的影响可忽略不计，把滤波器截短可以得到： $$ y(kT_{sp})=\\sum_{m=-3}^{+2} h_{T}\\left(\\mu_{k}+m\\right) x\\left(m_{k}-m\\right) $$\n具体做法：\n用Matlab 的 rcosdesign 函数生成一组 α=0.35,过采样倍数为 4096,双边 6 个符号的系数,将其量化为 12bit,然后按符号分为 6 组,每组 4096 个系数,分别存入6 个 ROM 核中,ROM 核宽度为 12,深度为 4096。这样，我们将$\\mu_k$和$m$均扩大$2^{12}$倍作为索引地址，分别把运算所需的6个系数都求出来。\n假设当前采样率为5Gsps，在200MHz及以下时钟频率下，要32路并行运算，可以将公式修改为 $$ y(32n+i) = \\sum_{m=-3}^{+2}h_T(\\mu_n(i)+m)x(m_n(i)-m) $$ 式中$n$为时刻值，$i$为并行的路数的序数。$m_{n}(i)=\\left\\lfloor\\frac{(32 n+i) T_{s p}}{T_{s}}\\right\\rfloor$，$\\mu_{n}(i)=\\frac{(32 n+i) T_{s p}}{T_{s}}-m_{n}(i)$。\n整个模块的实现框图如下所示：输入的符号数据先通过FIFO缓存，再输出给DataCache，由COEGen算出$m_n(i)$和$\\mu_n(i)$，分别从DataCache和FilterRom中取出6对待内插成型的符号和滤波器系数，相乘求和即得到一路成型输出。\n可变速率成型滤波模块的一些参数讨论 本项目用到的最高采样率为$5Gsps$，最高符号速率为$1200Msps$，在这个条件下，有$\\frac{32T_{sp}}{T_s}=7.68$，即在32路并行时，$m_n(1)$和$m_n(32)$最多相差8，因此，$m_n(i)$的取值区间为$[0, 7]$，再考虑上$m_{n}(1)-2$和$m_{n}(32)+3$，在32路并行成型滤波时，共需要13个符号参与运算。所以DataCache需要对从FIFO输入的8路并行符号数据缓存一拍，接到下一个时刻的数据之前，变成16路并行的数据，以满足滤波的速率要求。\n寄存器寻址方案，为了使精度能够满足设计的需要，我们用53位表示$\\frac{(32 n+i) T_{s p}}{T_{s}}$，其中3位整数位，50位小数位，即$m_n(i)$取整数位3位，$\\mu_n(i)$取高12小数位。\n还有FIFO取数的策略，这个直接参考文献即可。\n高速并行匹配滤波器的实现 $Z$变换 向系统输入$\\delta(n)$得到脉冲响应$h(n)$，例如$h(n)=\\left[\\begin{array}{lll}1 \u0026amp; 2 \u0026amp; 1\\end{array}\\right]$\n这时候我们再向系统输入另外一个信号，例如：$x(n)=[1\\quad 2\\quad 1]=\\delta(n)+2 \\delta(n-1)+\\delta(n-2)$\n那么输出信号就应该是$y(n)=[1\\quad 4\\quad 6\\quad 4\\quad 1]=h(n)+2 h(n-1)+h(n-2)=x(n)* h(n)$（卷积运算）\n经过观察可以发现，这其实就是$[1\\quad 2\\quad 1]$和$[1\\quad 2\\quad 1]$的多项式相乘！！！\n因此我们将信号$x(n)$改写成$X(Z)=1+2 Z^{-1}+Z^{-2}$，同理，脉冲响应也写成$H(Z)=1+2 Z^{-1}+Z^{-2}$，则有$Y(Z) = 1+4 Z^{-1}+6 Z^{-2}+4 Z^{-3}+Z^{-4} = X(Z)H(Z)$，这种变换就称为$Z$变换。\n⭐️ $Z^{-1}$对应的是下一个时钟周期（未来）的数据\n公式推导 一个N阶的 FIR 滤波器在时域上可表示为： $$ y(n)=h(n) * x(n)=\\sum_{i=0}^{N-1} h(i) x(n-i), \\quad n=0,1,2, \\ldots, \\infty $$ 上式对应的Z变换可以表示为： $$ Y(z)=H(z) \\cdot X(z)=\\left(\\sum_{n=0}^{N-1} h(n) z^{-n}\\right) \\cdot\\left(\\sum_{n=0}^{\\infty} x(n) z^{-n}\\right) $$ 根据论文，可以将序列$x(n)$和$h(n)$的$z$变换拆分成偶数时间序列和奇数时间序列的$Z$变换： $$ \\begin{aligned} X(z) \u0026amp;=x(0)+x(1) z^{-1}+x(2) z^{-2}+x(3) z^{-3}+\\cdots+x(n) z^{-n} \\\\ \u0026amp;=\\left[x(0)+x(2) z^{-2}+x(4) z^{-4}+x(6) z^{-6} \\cdots\\right] \\\\ \u0026amp;+z^{-1}\\left[x(1)+x(3) z^{-2}+x(5) z^{-4}+x(7) z^{-6} \\cdots\\right] \\\\ \u0026amp;=X_{0}\\left(z^{2}\\right)+z^{-1} X_{1}\\left(z^{2}\\right) \\end{aligned} $$ 同理，有 $$ H(z)=H_{0}\\left(z^{2}\\right)+z^{-1} H_{1}\\left(z^{2}\\right) $$\n则对应的$y(n)$序列也可以表示为偶数时间序列和奇数时间序列的求和： $$ Y(z)=Y_{0}\\left(z^{2}\\right)+z^{-1} Y_{1}\\left(z^{2}\\right) $$\n$$ \\begin{array}{c} Y_{0}\\left(z^{2}\\right)=X_{0}\\left(z^{2}\\right) H_{0}\\left(z^{2}\\right)+\\mathrm{z}^{-2}\\left(X_{1}\\left(z^{2}\\right) H_{1}\\left(z^{2}\\right)\\right) \\\\ Y_{1}\\left(z^{2}\\right)=X_{0}\\left(z^{2}\\right) H_{1}\\left(z^{2}\\right)+X_{1}\\left(z^{2}\\right) H_{0}\\left(z^{2}\\right) \\end{array} $$\n写成矩阵形式可有： $$ \\left[\\begin{array}{c} Y_{0} \\\\ Y_{1} \\end{array}\\right]=\\left[\\begin{array}{cc} H_{0} \u0026amp; z^{-2} H_{1} \\\\ H_{1} \u0026amp; H_{0} \\end{array}\\right] \\cdot\\left[\\begin{array}{c} X_{0} \\\\ X_{1} \\end{array}\\right] $$ 假设L路并行，则可对其进行拓展： $$ \\left[\\begin{array}{c} Y_{0} \\\\ Y_{1} \\\\ \\ldots \\\\ Y_{L-1} \\end{array}\\right]=\\left[\\begin{array}{cccc} H_{0} \u0026amp; z^{-L} H_{L-1} \u0026amp; \\ldots \u0026amp; z^{-L} H_{1} \\\\ H_{1} \u0026amp; H_{0} \u0026amp; \\ldots \u0026amp; z^{-L} H_{2} \\\\ \\ldots \u0026amp; \\ldots \u0026amp; \\ldots \u0026amp; \\ldots \\\\ H_{L-1} \u0026amp; H_{L-2} \u0026amp; \\ldots \u0026amp; H_{0} \\end{array}\\right] \\cdot\\left[\\begin{array}{c} X_{0} \\\\ X_{1} \\\\ \\ldots \\\\ X_{L-1} \\end{array}\\right] $$\n高速并行匹配滤波器的实现方法 此处采用32路并行，输入的IQ数据各只有16路，滤波器的系数长度为25，即rcosdesign(0.35, 4, 6, 'sqrt')。\n为了简单，此处先假设滤波器系数长度为32，推导出其做法，再简化成滤波器系数长度为25的情况。对于I路来说，其输入$x(n)$只有偶数序列的形式，即只有$x(2k)$的情况下不为0，$x(2k+1)$的情况下恒等于0，但其依旧对应两组（每组长度16）的输出，分别为 $$ Y_{2 k}=\\left\\lbrace\\begin{array}{cc} \\left(\\sum_{i=0}^{k} H_{2 i} X_{2(k-i)}\\right)+z^{-32}\\left(\\sum_{i=k+1}^{15} H_{2 i} X_{32+2(k-i)}\\right), \u0026amp; 0 \\leq k \\leq 14 \\\\ \\sum_{i=0}^{15} H_{2 i} X_{2(k-i)}, \u0026amp; k=15 \\end{array}\\right. $$\n$$ Y_{2 k+1}=\\left\\lbrace\\begin{array}{cc} \\left(\\sum_{i=0}^{k} H_{2 i+1} X_{2(k-i)}\\right)+z^{-32}\\left(\\sum_{i=k+1}^{15} H_{2 i+1} X_{32+2(k-i)}\\right), \u0026amp; 0 \\leq k \\leq 14 \\\\ \\sum_{i=0}^{15} H_{2 i+1} X_{2(k-i)}, \u0026amp; k=15 \\end{array}\\right. $$\n其实也就是 $$ \\left[\\begin{array}{c} Y_{0} \\\\ Y_{1} \\\\ \\ldots \\\\ Y_{31} \\end{array}\\right]=\\left[\\begin{array}{cccc} H_{0} \u0026amp; z^{-32} H_{31} \u0026amp; \\ldots \u0026amp; z^{-32} H_{1} \\\\ H_{1} \u0026amp; H_{0} \u0026amp; \\ldots \u0026amp; z^{-32} H_{2} \\\\ \\ldots \u0026amp; \\ldots \u0026amp; \\ldots \u0026amp; \\ldots \\\\ H_{31} \u0026amp; H_{30} \u0026amp; \\ldots \u0026amp; H_{0} \\end{array}\\right] \\cdot\\left[\\begin{array}{c} X_{0} \\\\ 0 \\\\ X_{2}\\\\ 0\\\\ X_{3}\\\\ \\ldots \\\\ X_{30}\\\\ 0 \\end{array}\\right] $$ 同理，对于Q路也一样，为 $$ \\left[\\begin{array}{c} Y_{0} \\\\ Y_{1} \\\\ \\ldots \\\\ Y_{31} \\end{array}\\right]=\\left[\\begin{array}{cccc} H_{0} \u0026amp; z^{-32} H_{31} \u0026amp; \\ldots \u0026amp; z^{-32} H_{1} \\\\ H_{1} \u0026amp; H_{0} \u0026amp; \\ldots \u0026amp; z^{-32} H_{2} \\\\ \\ldots \u0026amp; \\ldots \u0026amp; \\ldots \u0026amp; \\ldots \\\\ H_{31} \u0026amp; H_{30} \u0026amp; \\ldots \u0026amp; H_{0} \\end{array}\\right] \\cdot\\left[\\begin{array}{c} 0\\\\ X_{1} \\\\ 0 \\\\ X_{3}\\\\ \\ldots \\\\ 0\\\\ X_{31} \\end{array}\\right] $$\n$$ Y_{2 k}=\\left\\lbrace\\begin{array}{cc}z^{-32}\\left(\\sum_{i=0}^{15} H_{2 i+1} X_{31+2(k-i)}\\right), \u0026amp; k=0 \\\\ \\left(\\sum_{i=0}^{k-1} H_{2 i+1} X_{2(k-i)-1}\\right)+z^{-32}\\left(\\sum_{i=k}^{15} H_{2 i+1} X_{31+2(k-i)}\\right), \u0026amp; 1 \\leq k \\leq 15\\end{array}\\right. $$\n$$ Y_{2 k+1}=\\left\\lbrace\\begin{array}{cc} \\left(\\sum_{i=0}^{k} H_{2 i} X_{2(k-i)+1}\\right)+z^{-32}\\left(\\sum_{i=k+1}^{15} H_{2 i} X_{33+2(k-i)}\\right), \u0026amp; 0 \\leq k \\leq 14 \\\\ \\sum_{i=0}^{15} H_{2 i} X_{2(k-i)+1}, \u0026amp; k=15 \\end{array}\\right. $$\n如果对里面的元素全部分别相乘，可以看出，对于$H$矩阵的第一列，会分别与$X_0$相乘，对于$H$矩阵的第三列，会分别与$X_2$相乘，对于$H$矩阵的第31列，会分别与$X_{30}$相乘，乘出来待用的参数分别如下： $$ H_0X_0, \\quad H_1X_0, \\quad H_2X_0, \\quad H_3X_0, \\quad \\cdots, \\quad H_{31}X_0 $$\n$$ z^{-32}H_{30}X_2, \\quad z^{-32}H_{31}X_2, \\quad H_{0}X_2, \\quad H_{1}X_2, \\quad \\cdots, \\quad H_{29}X_2 $$\n$$ \\cdots $$\n$$ z^{-32}H_{1}X_{30}, \\quad z^{-32}H_{2}X_{30}, \\quad z^{-32}H_{3}X_{30}, \\quad z^{-32}H_{4}X_{30}, \\quad \\cdots, \\quad H_{0}X_{30} $$\n由于滤波器参数是对称的，所以其实$H_0X_0$和$H_{31}X_0$是一样的，因此只需要一半的滤波器系数即可，而且由于矩阵中有一半的运算是通过延迟32个时钟（这里32路并行，相当于只需要延迟一个时钟周期即可）实现的，所以可以将结果分成两部分，一部分先延时，再输入流水相加模块，另一部分直接输入流水相加模块，进行流水线相加，实现整个低通滤波的过程，其具体实现框图如图所示：\n对于匹配滤波的实现，由于其同样是32路并行输入并且其阶数只有25，即$H_{25}-H_{31}$均为0，其余系数$H_0-H_{24}$非0，所以可以列出其算法： $$ \\left[\\begin{array}{c} Y_{0} \\\\ Y_{1} \\\\ \\ldots \\\\ Y_{31} \\end{array}\\right]=\\left[\\begin{array}{ccccc} H_{0} \u0026amp; 0 \u0026amp; 0 \u0026amp; \\ldots \u0026amp; z^{-32} H_{1} \\\\ H_{1} \u0026amp; H_{0} \u0026amp; 0 \u0026amp; \\ldots \u0026amp; z^{-32} H_{2} \\\\ \\ldots \u0026amp; \\ldots \u0026amp; \\ldots \u0026amp; \\ldots \u0026amp; \\ldots \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\ldots \u0026amp; H_{0} \\end{array}\\right] \\cdot\\left[\\begin{array}{c} X_{0} \\\\ X_{1} \\\\ \\ldots \\\\ X_{31} \\end{array}\\right] $$ 其实现过程与低通滤波器的实现过程几乎一致，只不过有不少空白的系数可以省去运算步骤。\n为了Matlab实现时查找的方便，下面分别列出32路并行的I路和Q路对应的矩阵表达式以及求和公式： $$ Y_I= \\left[\\begin{array}{c} Y_{0} \\\\ Y_{1} \\\\ \\ldots \\\\ Y_{31} \\end{array}\\right]=\\left[\\begin{array}{ccccc} H_{0} \u0026amp; 0 \u0026amp; 0 \u0026amp; \\ldots \u0026amp; z^{-32} H_{1} \\\\ H_{1} \u0026amp; H_{0} \u0026amp; 0 \u0026amp; \\ldots \u0026amp; z^{-32} H_{2} \\\\ \\ldots \u0026amp; \\ldots \u0026amp; \\ldots \u0026amp; \\ldots \u0026amp; \\ldots \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\ldots \u0026amp; H_{0} \\end{array}\\right] \\cdot\\left[\\begin{array}{c} X_{0} \\\\ 0 \\\\ X_{2}\\\\ 0\\\\ \\ldots \\\\ X_{30}\\\\ 0 \\end{array}\\right] $$\n$$ Y_{I(2 k)}=\\left\\lbrace\\begin{array}{cc} \\left(\\sum_{i=0}^{k} H_{2 i} X_{2(k-i)}\\right)+z^{-32}\\left(\\sum_{i=k+1}^{12} H_{2 i} X_{32+2(k-i)}\\right), \u0026amp; 0 \\leq k \u0026lt;12 \\\\ \\sum_{i=0}^{12} H_{2 i} X_{2(k-i)}, \u0026amp; 12 \\leq k \\leq 15 \\end{array}\\right. $$\n$$ Y_{I(2 k+1)}=\\left\\lbrace\\begin{array}{cc} \\left(\\sum_{i=0}^{k} H_{2 i+1} X_{2(k-i)}\\right)+z^{-32}\\left(\\sum_{i=k+1}^{11} H_{2 i+1} X_{32+2(k-i)}\\right), \u0026amp; 0 \\leq k \\leq 11 \\\\ \\sum_{i=0}^{11} H_{2 i+1} X_{2(k-i)}, \u0026amp; 11 \\leq k \\leq 15 \\end{array}\\right. $$\n$$ Y_Q= \\left[\\begin{array}{c} Y_{0} \\\\ Y_{1} \\\\ \\ldots \\\\ Y_{31} \\end{array}\\right]=\\left[\\begin{array}{ccccc} H_{0} \u0026amp; 0 \u0026amp; 0 \u0026amp; \\ldots \u0026amp; z^{-32} H_{1} \\\\ H_{1} \u0026amp; H_{0} \u0026amp; 0 \u0026amp; \\ldots \u0026amp; z^{-32} H_{2} \\\\ \\ldots \u0026amp; \\ldots \u0026amp; \\ldots \u0026amp; \\ldots \u0026amp; \\ldots \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\ldots \u0026amp; H_{0} \\end{array}\\right] \\cdot\\left[\\begin{array}{c} 0 \\\\ X_{1} \\\\ 0\\\\ X_{3}\\\\ \\ldots \\\\ 0\\\\ X_{31} \\end{array}\\right] $$\n$$ Y_{Q(2 k)}=\\left\\lbrace\\begin{array}{cc} z^{-32}\\left(\\sum_{i=0}^{11} H_{2 i+1} X_{31+2(k-i)}\\right), \u0026amp; k=0 \\\\ \\left(\\sum_{i=0}^{k-1} H_{2 i+1} X_{2(k-i)-1}\\right)+z^{-32}\\left(\\sum_{i=k}^{11} H_{2 i+1} X_{31+2(k-i)}\\right), \u0026amp; 0 \u0026lt; k \\leq 12 \\\\ \\left(\\sum_{i=0}^{11} H_{2 i+1} X_{2(k-i)-1}\\right), \u0026amp; 12 \\leq k \\leq 15 \\end{array}\\right. $$\n$$ Y_{Q(2 k+1)}=\\left\\lbrace\\begin{array}{cc} \\left(\\sum_{i=0}^{k} H_{2 i} X_{2(k-i)+1}\\right)+z^{-32}\\left(\\sum_{i=k+1}^{12} H_{2 i} X_{33+2(k-i)}\\right), \u0026amp; 0 \\leq k \u0026lt; 13 \\\\ \\sum_{i=0}^{12} H_{2 i} X_{2(k-i)+1}, \u0026amp; 13 \\leq k \\leq 15 \\end{array}\\right. $$\n64路并行的也直接罗列于此： 对于I路，有\n$$ Y_{I(2 k)}=\\left\\lbrace\\begin{array}{cl} \\left(\\sum_{i=0}^{k} H_{2 i} X_{2(k-i)}\\right)+z^{-64}\\left(\\sum_{i=k+1}^{31} H_{2 i} X_{64+2(k-i)}\\right) \u0026amp; 0 \\leq k \\leq 30 \\\\ \\sum_{i=0}^{31} H_{2 i} X_{2(k-i)} \u0026amp; , k=31 \\end{array}\\right. $$ $$ Y_{I(2 k+1)}=\\left\\lbrace\\begin{array}{cc} \\left(\\sum_{i=0}^{k} H_{2 i+1} X_{2(k-i)}\\right)+z^{-64}\\left(\\sum_{i=k+1}^{31} H_{2 i+1} X_{64+2(k-i)}\\right) \u0026amp; , 0 \\leq k \\leq 30 \\\\ \\sum_{i=0}^{31} H_{2 i+1} X_{2(k-i)} \u0026amp; , k=31 \\end{array}\\right. $$\n对应的矩阵表示为：\n$$ \\left[\\begin{array}{c} Y_{0} \\\\ Y_{1} \\\\ \\cdots \\\\ Y_{63} \\end{array}\\right]=\\left[\\begin{array}{cccc} H_{0} \u0026amp; z^{-64} H_{63} \u0026amp; \\cdots \u0026amp; z^{-64} H_{1} \\\\ H_{1} \u0026amp; H_{0} \u0026amp; \\cdots \u0026amp; z^{-64} H_{2} \\\\ \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \\\\ H_{63} \u0026amp; H_{62} \u0026amp; \\cdots \u0026amp; H_{0} \\end{array}\\right]\\left[\\begin{array}{c} X_{0} \\\\ 0 \\\\ X_{2} \\\\ 0 \\\\ X_{4} \\\\ \\cdots \\\\ X_{62} \\\\ 0 \\end{array}\\right] $$\n同理，Q路为：\n$$ \\left[\\begin{array}{c} Y_{0} \\\\ Y_{1} \\\\ \\cdots \\\\ Y_{63} \\end{array}\\right]=\\left[\\begin{array}{cccc} H_{0} \u0026amp; z^{-64} H_{63} \u0026amp; \\cdots \u0026amp; z^{-64} H_{1} \\\\ H_{1} \u0026amp; H_{0} \u0026amp; \\cdots \u0026amp; z^{-64} H_{2} \\\\ \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \\\\ H_{63} \u0026amp; H_{62} \u0026amp; \\cdots \u0026amp; H_{0} \\end{array}\\right]\\left[\\begin{array}{c} 0 \\\\ X_{1} \\\\ 0 \\\\ X_{3} \\\\ 0 \\\\ X_{5} \\\\ \\cdots \\\\ 0 \\\\ X_{63} \\end{array}\\right] $$\n"}]